
[[jc-method]]
= Method Security

In addition to modeling authorization at the request level, Spring Security also supports modeling at the method level.

You can activate it in your application with the following class-level annotation on any `@Configuration` class or XML directive in your Spring configuration XML files:

====
.Java
[source,java,role="primary"]
----
@EnableMethodSecurity
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableMethodSecurity
----

.Xml
[source,xml,role="secondary"]
----
<sec:method-security/>
----
====

[NOTE]
Spring Boot does not activate method-level authorization by default.

Then, you are immediately able to annotate any Spring-managed classes or methods with `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, and `@PostFilter` to authorize the input parameters, invocation, and return values of any methods intercepted by Spring AOP.

From here, you can learn about:

* How to migrate from `@EnableGlobalMethodSecurity`
* How <<method-security-architecture,method security works>> and reasons to use it
* How to configure methods when one Spring-Security-annotated method calls another.
* How to evaluate the difference between doing <<request-vs-method,request-level or method-level authorization>>
* How and when to use `@PreAuthorize`
* How and when to use `@PostAuthorize`
* How and when to use `@PreFilter` and `@PostFilter`
* How to use JSR-250 annotations
* How to integrate with AspectJ
* How to use custom authorization managers
* How to mix-in authorization for individual objects

[[method-security-architecture]]
== How Method Security Works

Spring Security's method authorization support is handy for:

* Extracting fine-grained authorization logic; for example, when the method parameters and return values contribute to the authorization decision.
* Enforcing security at the service layer
* Stylistically favoring annotation-based over bean-based configuration

And since Method Security is built using Spring AOP, you have access to all its expressive power to override Spring Security's defaults as needed.

Consider a service bean that is annotated for Method Security in the following way:

====
.Java
[source,java,role="primary"]
----
@Service
public class MyCustomerService {
    @PreAuthorize("hasAuthority('permission:read')")
    public Customer readCustomer(String id) { ... }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Service
@PreAuthorize("hasAuthority('permission:read')")
open class MyCustomerService {
    @PostAuthorize("returnObject.owner == authentication.name")
    fun readCustomer(val id: String): Customer { ... }
}
----
====

A given invocation to `MyCustomerService#readCustomer` may look something like this when Method Security is activated:

1. Spring AOP invokes its proxy method for `readCustomer`
2. Among the proxy's other advisors, it invokes an `AuthorizationManagerBeforeMethodInterceptor` that matches the `@PreAuthorize` pointcut
3. The interceptor finds the annotation, reads, and parses its SpEL expression
4. The interceptor delegates to a `MethodSecurityExpressionHandler`.
This handler uses a `Supplier<Authentication>` and `MethodInvocation` to formulate a `MethodSecurityExpressionRoot`
5. The expression handler then takes this root, an `AuthenticationTrustResolver`, a `BeanResolver`, a `ParameterNameResolver`, and other components to formulate a `MethodBasedEvaluationContext`, handing the context back to the interceptor
6. The interceptor uses this context to evaluate the expression; specifically, it reads the `Authentication` from the `Supplier` and checks whether it has `permission:read` in its collection of authorities
7. If so, then Spring AOP proceeds with processing the `@PostAuthorize` advisor in the same way, checking if the returned `Customer` belongs to the currently logged-in user
8. If so, Spring AOP proceeds with any remaining Spring AOP advice
9. If not, Spring AOP propagates an `AccessDeniedException` (which is caught by the `ExceptionTranslationFilter` in servlet-based applications)

[NOTE]
If the method is not being called in the context of an HTTP request, you will likely need to handle the `AccessDeniedException` yourself

=== Multiple Annotations Are Computed In Series

As demonstrated above, if a method invocation involves multiple Spring Security annotations, each of those is processed one at a time.
This means that they can collectively be thought of as being anded together.
In other words, for an invocation to be authorized, all annotation inspections need to pass authorization.

=== Repeated Annotations Are Not Supported

That said, it is not supported to repeat the same annotation on the same method.
For example, you cannot please `@PreAuthorize` twice on the same method.

Instead, use SpEL's boolean support or its support for delegating to a separate bean.

=== Each Annotation Has Its Own Method Interceptor

Each annotation has its own dedicated method interceptor.
The reason for this is to make things more composable.
For example, if needed, you can disable the Spring Security defaults and publish only the `@PostAuthorize` method interceptor.

The method interceptors are as follows:

* For `@PreAuthorize`, Spring Security uses `AuthenticationManagerBeforeMethodInterceptor#preAuthorize`, which in turn uses `PreAuthorizeAuthorizationManager`
* For `@PostAuthorize`, Spring Security uses `AuthenticationManagerAfterMethodInterceptor#postAuthorize`, which in turn uses `PostAuthorizeAuthorizationManager`
* For `@PreFilter`, Spring Security uses `PreFilterAuthorizationMethodInterceptor`
* For `@PostFilter`, Spring Security uses `PostFilterAuthorizationMethodInterceptor`
* For `@Secured`, Spring Security uses `AuthenticationManagerBeforeMethodInterceptor#secured`, which in turn uses `SecuredAuthorizationManager`
* For JSR-250 annotations, Spring Security uses `AuthenticationManagerBeforeMethodInterceptor#jsr250`, which in turn uses `Jsr250AuthorizationManager`

=== Favor Granting Authorities Over SpEL Boolean Expressions

Quite often it can be tempting to introduce a complicated SpEL expression like the following:

====
.Java
[source,java,role="primary"]
----
@PreAuthorize("hasAuthority('permission:read') || hasRole('ADMIN')")
----

.Kotlin
[source,kotlin,role="kotlin"]
----
@PreAuthorize("hasAuthority('permission:read') || hasRole('ADMIN')")
----
====

However, you could instead grant `permission:read` to those with `ROLE_ADMIN`.
One way to do this is with a `RoleHierarchy` like so:

```java
@Bean
RoleHierarchy roleHierarchy() {
    return new RoleHierarchyImpl("ROLE_ADMIN > permission:read");
}
```

which then allows you to have a simpler `@PreAuthorize` expression like this one:

```java
@PreAuthorize("hasAuthority('permission:read')")
```

[[request-vs-method]]
== Evaluating Request-level vs Method-level Authorization

When should you favor method-level authorization over request-level authorization?
Some of it comes down to taste; however, consider the following strengths list of each to help you decide.

|| request-level | method-level |
| authorization type | coarse-grained | fine-grained |
| configuration location | declared in a config class | local to method declaration |
| configuration style | DSL | Annotations |
| authorization definitions | programmatic | SpEL |

The main tradeoff seems to be where you want your authorization rules to live.

[NOTE]
It's important to remember that if you are going to use method-level security, then unannotated methods are not secured.
To protect against this, it's strongly recommend that your `HttpSecurity` declaration protect all requests by default.

== Authorizing Method Invocation with `@PreAuthorize`

When Method Security is active, you can annotate a method with `@PreAuthorize` like so:

```java
public class BankService {
	@PreAuthorize("hasRole('ADMIN')")
	public Account readAccount(Long id) {
        // ... is only invoked if the `Authentication` has the `ROLE_ADMIN` authority
	}
}
```

This is meant to indicate that the method can only be invoked if the provided expression passes.

You can then test the class to confirm it is enforcing the authorization rule:

```java
@Autowired
BankService bankService;

@WithMockUser(roles="ADMIN")
@Test
void readAccountWithAdminRoleThenInvokes() {
    Account account = this.bankService.readAccount("12345678");
    // ... assertions
}

@WithMockUser(roles="WRONG")
@Test
void readAccountWithWrongRoleThenAccessDenied() {
    assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(
        () -> this.bankService.readAccount("12345678"));
}
```

[TIP]
`@PreAuthorize` also can be a meta-annotation, be defined at the class or interface level, and use the full expressive power of SpEL.

While `@PreAuthorize` is quite helpful for declaring needed authorities, it can also be used to evaluate more complex permissions that involve the method parameters.
To achieve that, you can use Spring Security's `@P` annotation to remember the parameter name:

```java
@PreAuthorize("#username == authentication.name")
Collection<Order> findOrders(@P("username") String username) { ... }
```

Or, Spring Security also integrations with Spring MVC to identify parameters like so:

```java
@GetMapping("/orders/{username}")
@PreAuthorize("#username == authentication.name")
Collection<Order> findOrders(@PathVariable("username") String username) { ... }
```

== Authorization Method Results with `@PostAuthorize`

When Method Security is active, you can annotate a method with `@PostAuthorize` like so:

```java
public class BankService {
	@PostAuthorize("returnObject.owner == authentication.name")
	public Account readAccount(Long id) {
        // ... is only returned if the `Account` belongs to the logged in user
	}
}
```

This is meant to indicate that the method can only return the value if the provided expression passes.

You can then test the class to confirm it is enforcing the authorization rule:

```java
@Autowired
BankService bankService;

@WithMockUser(username="owner")
@Test
void readAccountWhenOwnedThenReturns() {
    Account account = this.bankService.readAccount("12345678");
    // ... assertions
}

@WithMockUser(username="wrong")
@Test
void readAccountWhenNotOwnedThenAccessDenied() {
    assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(
        () -> this.bankService.readAccount("12345678"));
}
```

[TIP]
`@PostAuthorize` also can be a meta-annotation, be defined at the class or interface level, and use the full expressive power of SpEL.

`@PostAuthorize` is particularly helpful when defending against Insecure Direct Object Reference.
In fact, it can be defined as a meta-annotation like so:

```java
@Target({ ElementType.METHOD, ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@PostAuthorize("returnObject.owner == authentication.name")
public @interface RequireOwnership {}
```

Allowing you to instead annotate the service like so:

```java
public class BankService {
	@RequireOwnership
	public Account readAccount(Long id) {
        // ... is only returned if the `Account` belongs to the logged in user
	}
}
```

== Filtering Method Parameters with `@PreFilter`

When Method Security is active, you can annotate a method with `@PreFilter` like so:

```java
public class BankService {
	@PreFilter("filterObject.owner == authentication.name")
	public Collection<Account> updateAccounts(Account... accounts) {
        // ... `accounts` will only contain the accounts owned by the logged-in user
        return updated;
	}
}
```

This is meant to filter out any values from `accounts` where the expression fails.

You can then test the class to confirm it is enforcing the authorization rule:

```java
@Autowired
BankService bankService;

@WithMockUser(username="owner")
@Test
void updateAccountsWhenOwnedThenReturns() {
    Account ownedBy = ...
    Account notOwnedBy = ...
    Collection<Account> updated = this.bankService.updateAccounts(ownedBy, notOwnedBy);
    assertThat(updated).containsOnly(ownedBy);
}
```

[TIP]
`@PreFilter` also can be a meta-annotation, be defined at the class or interface level, and use the full expressive power of SpEL.

`@PreFilter` supports arrays, collections, maps, and streams (so long as the stream is still open).

For example, the above example will function the same way with the following other four definitions:

```java
@PreFilter("filterObject.owner == authentication.name")
public Collection<Account> updateAccounts(Account[] accounts)

@PreFilter("filterObject.owner == authentication.name")
public Collection<Account> updateAccounts(Collection<Account> accounts)

@PreFilter("filterObject.value.owner == authentication.name")
public Collection<Account> updateAccounts(Map<String, Account> accounts)

@PreFilter("filterObject.owner == authentication.name")
public Collection<Account> updateAccounts(Stream<Account> accounts)
```

== Filtering Method Results with `@PostFilter`

When Method Security is active, you can annotate a method with `@PostFilter` like so:

```java
public class BankService {
	@PostFilter("filterObject.owner == authentication.name")
	public Collection<Account> readAccounts(String... ids) {
        // ... the return value will be filtered to only contain the accounts owned by the logged-in user
        return accounts;
	}
}
```

This is meant to filter out any values from the return value where the expression fails.

You can then test the class to confirm it is enforcing the authorization rule:

```java
@Autowired
BankService bankService;

@WithMockUser(username="owner")
@Test
void readAccountsWhenOwnedThenReturns() {
    Collection<Account> accounts = this.bankService.updateAccounts("owner", "not-owner");
    assertThat(accounts).hasSize(1);
    assertThat(accounts.get(0).getOwner()).isEqualTo("owner");
}
```

[TIP]
`@PostFilter` also can be a meta-annotation, be defined at the class or interface level, and use the full expressive power of SpEL.

`@PostFilter` supports arrays, collections, maps, and streams (so long as the stream is still open).

For example, the above example will function the same way with the following other three definitions:

```java
@PostFilter("filterObject.owner == authentication.name")
public Account[] readAccounts(String... ids)

@PostFilter("filterObject.value.owner == authentication.name")
public Map<String, Account> readAccounts(String... ids)

@PostFilter("filterObject.owner == authentication.name")
public Stream<Account> readAccounts(String... ids)
```

[NOTE]
In-memory filtering can obviously be expensive, and so be considerate of whether it is better to filter the data in the data layer instead.

== Authorizing Method Invocatino with `@Secured`

`@Secured` is a legacy option for authorizing invocations.
`@PreAuthorize` supercedes it.

== Using JSR-250 Annotations

In case you would like to use JSR-250 annotations, Spring Security also supports that.
Again, `@PreAuthorize` is quite a bit more powerful and is thus recommended.

== Declaring Annotations at the Class or Interface Level

It's also supported to have Method Security annotations at the class and interface level.

If it is at the class level like so:

then all methods inherit the class-level behavior.

If it is at both the class and method level like so:

then methods declaring the annotation override the class-level annotation.

The same is true for interfaces, with the exception that if a class inherits the annotation from two different interfaces, then startup with fail.
This is because Spring Security has no way to tell which one you want to use.

In cases like this, you can resolve the ambiguity by adding the annotation to the concrete method.

== Using Meta Annotations

Method Security supports meta annotations.
This means that you can take any annotation and improve readability based on your application-specific use cases.

For example, you can simplify `@PreAuthorize("hasRole('ADMIN')")` to `@IsAdmin` like so:

And the result is that on your secured methods you can now do the following instead:

This results in more readable method definitions.

== Authorize Methods Programmatically

As you've already seen, there are several ways that you can specify non-trivial authorization rules using Method Security annotations.
That said, they are limited to what can be expressed with SpEL.
Instead, we can access the entire Java language for increased testibility and flow control.

=== Custom Bean in SpEL

The first way to authorize a method programmatically is a two step process.

First, declare a bean that has a method that takes a `MethodSecurityExpressionOperations` instance like the following:

Then, reference that bean in your annotations in the following way:

Spring Security will invoke the given method on that bean for each method invocation.

What's nice about this is all your authorization logic is in a separate class that can be independently unit tested and verified for correctness.
It also has access to the full Java language instead of being limited to what SpEL is capable of.

=== Custom Authorization Managers

The second way to authorize a method programmatically is two create a custom `AuthorizationManager`.

First, declare an authorization manager instance, perhaps like this one:

Then, change your `@EnableMethodSecurity` declaration to not create any method interceptors for you, like so:

And finally, publish your own method interceptor using the custom `AuthorizationManager` you created:

This has the same benefit as the first option with the advantage this also gives you control over declaring a more surgical pointcut.
In this case, Spring Security will only invoke your authorization manager for `PostAuthorize` annotations on methods.

=== Custom Expression Evaluation

The final way is to customize the `SecurityExpressionRoot` that gets handed to the SpEL evaluator.
Customizing the SpEL object is often unnecessary given the first two options, but is nice for increasing the readability of expressions that can't simply be abstracted away into a meta annotation.

For example, consider OAuth 2.0 scopes.
You may want to differentiate between `hasAuthority`, `hasRole`, and `hasScope` in your expressions.

In this case, you can provide a custom `MethodSecurityExpressionOperations` and `MethodSecurityExpressionHandler`.

First, you can create a `MethodSecurityExpressionOperations` that includes the `hasScope` method like the following one:

```java
public class MyMethodSecurityExpressionRoot implements MethodSecurityExpressionOperations {
    private final MethodSecurityExpressionOperations delegate;

    public MyMethodSecurityExpressionRoot(MethodSecurityExpressionOperations delegate) {
        this.delegate = delegate;
    }

    // ... implement delegate methods

    public boolean hasScope(String scope) {
        return hasAuthority("SCOPE_" + scope);
    }
}
```

Then, you can create a `MethodSecurityExpressionHandler` that uses your `MyMethodSecurityExpressionRoot`, as follows:

```java
@Bean
static MethodSecurityExpressionHandler myMethodSecurityExpressionHandler() {
    DefaultMethodSecurityExpressionHandler standard = new DefaultMethodSecurityExpressionHandler() {
        @Override
	    public EvaluationContext createEvaluationContext(Supplier<Authentication> authentication, MethodInvocation mi) {
            EvaluationContext context = super.createEvaluationContext(authentication, mi);
            MethodSecurityExpressionOperations delegate = (MethodSecurityExpressionOperations) context.getRootObject();
            context.setRootObject(new MyMethodSecurityExpressionRoot(delegate));
            return context;
	    }
    }
}
```

At that point, you can use your custom SpEL method in Method Security annotations like the following one:

```java
@PreAuthorize("hasScope('message:read')")
```

== Bean-level Authorization

== Integrating with AspectJ

== Invoking Nested Annotated Methods

== Migrating from `@EnableGlobalMethodSecurity`

```java
import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasAuthority;

@Bean
Advisor getsRequireReadAuthority() {
    Pointcut pointcut = new AnnotationMatchingPointcut(null, GetMapping.class);
    return AuthorizationManagerBeforeMethodInvocation.annotation(GetMapping.class, hasAuthority("permission:read"));
}
```

By default, `@EnableMethodSecurity` or `<sec:method-security>` publishes a Spring AOP auto-proxy creator that allows Spring-managed beans to be proxied.
This allows Spring Security to intercept method invocation.
As already stated, Spring Security will then intercept and authorize any method that is annotated with `@PreAuthorize`, `@PostAuthorize`, `@PreFilter` or `@PostFilter`.


In addition to Spring Security's support for authorizing HTTP requests, you can also model your authorization at the method level.
Spring Security does not secure methods by default.
From version 2.0 onwards, Spring Security has improved support substantially for adding security to your service layer methods.
It provides support for JSR-250 annotation security as well as the framework's original `@Secured` annotation.
From 3.0, you can also make use of new xref:servlet/authorization/expression-based.adoc#el-access[expression-based annotations].
You can apply security to a single bean, by using the `intercept-methods` element to decorate the bean declaration, or you can secure multiple beans across the entire service layer by using AspectJ style pointcuts.

[[jc-enable-method-security]]
== EnableMethodSecurity

In Spring Security 5.6, we can enable annotation-based security using the `@EnableMethodSecurity` annotation on any `@Configuration` instance.

This improves upon `@EnableGlobalMethodSecurity` in a number of ways. `@EnableMethodSecurity`:

1. Uses the simplified `AuthorizationManager` API instead of metadata sources, config attributes, decision managers, and voters.
This simplifies reuse and customization.
2. Favors direct bean-based configuration, instead of requiring extending `GlobalMethodSecurityConfiguration` to customize beans
3. Is built using native Spring AOP, removing abstractions and allowing you to use Spring AOP building blocks to customize
4. Checks for conflicting annotations to ensure an unambiguous security configuration
5. Complies with JSR-250
6. Enables `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, and `@PostFilter` by default

[NOTE]
====
For earlier versions, please read about similar support with <<jc-enable-global-method-security, @EnableGlobalMethodSecurity>>.
====

For example, the following would enable Spring Security's `@PreAuthorize` annotation:

.Method Security Configuration
====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableMethodSecurity
public class MethodSecurityConfig {
	// ...
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableMethodSecurity
class MethodSecurityConfig {
	// ...
}
----

.Xml
[source,xml,role="secondary"]
----
<sec:method-security/>
----
====

Adding an annotation to a method (on a class or interface) would then limit the access to that method accordingly.
Spring Security's native annotation support defines a set of attributes for the method.
These will be passed to the `DefaultAuthorizationMethodInterceptorChain` for it to make the actual decision:

.Method Security Annotation Usage
====
.Java
[source,java,role="primary"]
----
public interface BankService {
	@PreAuthorize("hasRole('USER')")
	Account readAccount(Long id);

	@PreAuthorize("hasRole('USER')")
	List<Account> findAccounts();

	@PreAuthorize("hasRole('TELLER')")
	Account post(Account account, Double amount);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
interface BankService {
	@PreAuthorize("hasRole('USER')")
	fun readAccount(id : Long) : Account

	@PreAuthorize("hasRole('USER')")
	fun findAccounts() : List<Account>

	@PreAuthorize("hasRole('TELLER')")
	fun post(account : Account, amount : Double) : Account
}
----
====

You can enable support for Spring Security's `@Secured` annotation using:

.@Secured Configuration
====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
	// ...
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableMethodSecurity(securedEnabled = true)
class MethodSecurityConfig {
	// ...
}
----

.Xml
[source,xml,role="secondary"]
----
<sec:method-security secured-enabled="true"/>
----
====

or JSR-250 using:

.JSR-250 Configuration
====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
	// ...
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableMethodSecurity(jsr250Enabled = true)
class MethodSecurityConfig {
	// ...
}
----

.Xml
[source,xml,role="secondary"]
----
<sec:method-security jsr250-enabled="true"/>
----
====

=== Customizing Authorization

Spring Security's `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, and `@PostFilter` ship with rich xref:servlet/authorization/expression-based.adoc[expression-based support].

[[jc-method-security-custom-expression-handler]]
If you need to customize the way that expressions are handled, you can expose a custom `MethodSecurityExpressionHandler`, like so:

.Custom MethodSecurityExpressionHandler
====
.Java
[source,java,role="primary"]
----
@Bean
static MethodSecurityExpressionHandler methodSecurityExpressionHandler() {
	DefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler();
	handler.setTrustResolver(myCustomTrustResolver);
	return handler;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
companion object {
	@Bean
	fun methodSecurityExpressionHandler() : MethodSecurityExpressionHandler {
		val handler = DefaultMethodSecurityExpressionHandler();
		handler.setTrustResolver(myCustomTrustResolver);
		return handler;
	}
}
----

.Xml
[source,xml,role="secondary"]
----
<sec:method-security>
	<sec:expression-handler ref="myExpressionHandler"/>
</sec:method-security>

<bean id="myExpressionHandler"
		class="org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler">
	<property name="trustResolver" ref="myCustomTrustResolver"/>
</bean>
----
====

[TIP]
====
We expose `MethodSecurityExpressionHandler` using a `static` method to ensure that Spring publishes it before it initializes Spring Security's method security `@Configuration` classes
====

[[jc-method-security-custom-authorization-manager]]
=== Custom Authorization Managers

Method authorization is a combination of before- and after-method authorization.

[NOTE]
====
Before-method authorization is performed before the method is invoked.
If that authorization denies access, the method is not invoked, and an `AccessDeniedException` is thrown.
After-method authorization is performed after the method is invoked, but before the method returns to the caller.
If that authorization denies access, the value is not returned, and an `AccessDeniedException` is thrown
====

To recreate what adding `@EnableMethodSecurity` does by default, you would publish the following configuration:

.Full Pre-post Method Security Configuration
====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preFilterAuthorizationMethodInterceptor() {
		return new PreFilterAuthorizationMethodInterceptor();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preAuthorizeAuthorizationMethodInterceptor() {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor postAuthorizeAuthorizationMethodInterceptor() {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor postFilterAuthorizationMethodInterceptor() {
		return new PostFilterAuthorizationMethodInterceptor();
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preFilterAuthorizationMethodInterceptor() : Advisor {
		return PreFilterAuthorizationMethodInterceptor();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preAuthorizeAuthorizationMethodInterceptor() : Advisor {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun postAuthorizeAuthorizationMethodInterceptor() : Advisor {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun postFilterAuthorizationMethodInterceptor() : Advisor {
		return PostFilterAuthorizationMethodInterceptor();
	}
}
----

.Xml
[source,xml,role="secondary"]
----
<sec:method-security pre-post-enabled="false"/>

<aop:config/>

<bean id="preFilterAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor"/>
<bean id="preAuthorizeAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"
		factory-method="preAuthorize"/>
<bean id="postAuthorizeAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor"
		factory-method="postAuthorize"/>
<bean id="postFilterAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor"/>
----
====

Notice that Spring Security's method security is built using Spring AOP.
So, interceptors are invoked based on the order specified.
This can be customized by calling `setOrder` on the interceptor instances like so:

.Publish Custom Advisor
====
.Java
[source,java,role="primary"]
----
@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
Advisor postFilterAuthorizationMethodInterceptor() {
	PostFilterAuthorizationMethodInterceptor interceptor = new PostFilterAuthorizationMethodInterceptor();
	interceptor.setOrder(AuthorizationInterceptorOrders.POST_AUTHORIZE.getOrder() - 1);
	return interceptor;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
fun postFilterAuthorizationMethodInterceptor() : Advisor {
	val interceptor = PostFilterAuthorizationMethodInterceptor();
	interceptor.setOrder(AuthorizationInterceptorOrders.POST_AUTHORIZE.getOrder() - 1);
	return interceptor;
}
----

.Xml
[source,xml,role="secondary"]
----
<bean id="postFilterAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor">
	<property name="order"
			value="#{T(org.springframework.security.authorization.method.AuthorizationInterceptorsOrder).POST_AUTHORIZE.getOrder() -1}"/>
</bean>
----
====

You may want to only support `@PreAuthorize` in your application, in which case you can do the following:

.Only @PreAuthorize Configuration
====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preAuthorize() {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preAuthorize() : Advisor {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize()
	}
}
----

.Xml
[source,xml,role="secondary"]
----
<sec:method-security pre-post-enabled="false"/>

<aop:config/>

<bean id="preAuthorizeAuthorizationMethodInterceptor"
	class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"
	factory-method="preAuthorize"/>
----
====

Or, you may have a custom before-method `AuthorizationManager` that you want to add to the list.

In this case, you will need to tell Spring Security both the `AuthorizationManager` and to which methods and classes your authorization manager applies.

Thus, you can configure Spring Security to invoke your `AuthorizationManager` in between `@PreAuthorize` and `@PostAuthorize` like so:

.Custom Before Advisor
====

.Java
[source,java,role="primary"]
----
@Configuration
@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public Advisor customAuthorize() {
		JdkRegexpMethodPointcut pattern = new JdkRegexpMethodPointcut();
		pattern.setPattern("org.mycompany.myapp.service.*");
		AuthorizationManager<MethodInvocation> rule = AuthorityAuthorizationManager.isAuthenticated();
		AuthorizationManagerBeforeMethodInterceptor interceptor = new AuthorizationManagerBeforeMethodInterceptor(pattern, rule);
		interceptor.setOrder(AuthorizationInterceptorsOrder.PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun customAuthorize() : Advisor {
		val pattern = JdkRegexpMethodPointcut();
		pattern.setPattern("org.mycompany.myapp.service.*");
		val rule = AuthorityAuthorizationManager.isAuthenticated();
		val interceptor = AuthorizationManagerBeforeMethodInterceptor(pattern, rule);
		interceptor.setOrder(AuthorizationInterceptorsOrder.PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
	}
}
----

.Xml
[source,xml,role="secondary"]
----
<sec:method-security/>

<aop:config/>

<bean id="customAuthorize"
		class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor">
	<constructor-arg>
		<bean class="org.springframework.aop.support.JdkRegexpMethodPointcut">
			<property name="pattern" value="org.mycompany.myapp.service.*"/>
		</bean>
	</constructor-arg>
	<constructor-arg>
		<bean class="org.springframework.security.authorization.AuthorityAuthorizationManager"
				factory-method="isAuthenticated"/>
	</constructor-arg>
	<property name="order"
			value="#{T(org.springframework.security.authorization.method.AuthorizationInterceptorsOrder).PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1}"/>
</bean>
----
====

[TIP]
====
You can place your interceptor in between Spring Security method interceptors using the order constants specified in `AuthorizationInterceptorsOrder`.
====

The same can be done for after-method authorization.
After-method authorization is generally concerned with analysing the return value to verify access.

For example, you might have a method that confirms that the account requested actually belongs to the logged-in user like so:

.@PostAuthorize example
====
.Java
[source,java,role="primary"]
----
public interface BankService {

	@PreAuthorize("hasRole('USER')")
	@PostAuthorize("returnObject.owner == authentication.name")
	Account readAccount(Long id);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
interface BankService {

	@PreAuthorize("hasRole('USER')")
	@PostAuthorize("returnObject.owner == authentication.name")
	fun readAccount(id : Long) : Account
}
----
====

You can supply your own `AuthorizationMethodInterceptor` to customize how access to the return value is evaluated.

For example, if you have your own custom annotation, you can configure it like so:


.Custom After Advisor
====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public Advisor customAuthorize(AuthorizationManager<MethodInvocationResult> rules) {
		AnnotationMatchingPointcut pattern = new AnnotationMatchingPointcut(MySecurityAnnotation.class);
		AuthorizationManagerAfterMethodInterceptor interceptor = new AuthorizationManagerAfterMethodInterceptor(pattern, rules);
		interceptor.setOrder(AuthorizationInterceptorsOrder.POST_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun customAuthorize(rules : AuthorizationManager<MethodInvocationResult>) : Advisor {
		val pattern = AnnotationMatchingPointcut(MySecurityAnnotation::class.java);
		val interceptor = AuthorizationManagerAfterMethodInterceptor(pattern, rules);
		interceptor.setOrder(AuthorizationInterceptorsOrder.POST_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
	}
}
----

.Xml
[source,xml,role="secondary"]
----
<sec:method-security/>

<aop:config/>

<bean id="customAuthorize"
		class="org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor">
	<constructor-arg>
		<bean class="org.springframework.aop.support.annotation.AnnotationMethodMatcher">
			<constructor-arg value="#{T(org.mycompany.MySecurityAnnotation)}"/>
		</bean>
	</constructor-arg>
	<constructor-arg>
		<bean class="org.springframework.security.authorization.AuthorityAuthorizationManager"
				factory-method="isAuthenticated"/>
	</constructor-arg>
	<property name="order"
		value="#{T(org.springframework.security.authorization.method.AuthorizationInterceptorsOrder).PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1}"/>
</bean>
----
====

and it will be invoked after the `@PostAuthorize` interceptor.

[[jc-enable-global-method-security]]
== EnableGlobalMethodSecurity

We can enable annotation-based security by using the `@EnableGlobalMethodSecurity` annotation on any `@Configuration` instance.
The following example enables Spring Security's `@Secured` annotation:

====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
// ...
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true)
open class MethodSecurityConfig {
	// ...
}
----
====

Adding an annotation to a method (on a class or interface) would then limit the access to that method accordingly.
Spring Security's native annotation support defines a set of attributes for the method.
These are passed to the `AccessDecisionManager` for it to make the actual decision:

====
.Java
[source,java,role="primary"]
----
public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
interface BankService {
    @Secured("IS_AUTHENTICATED_ANONYMOUSLY")
    fun readAccount(id: Long): Account

    @Secured("IS_AUTHENTICATED_ANONYMOUSLY")
    fun findAccounts(): Array<Account>

    @Secured("ROLE_TELLER")
    fun post(account: Account, amount: Double): Account
}
----
====

Support for JSR-250 annotations can be enabled by using:

====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
// ...
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableGlobalMethodSecurity(jsr250Enabled = true)
open class MethodSecurityConfig {
	// ...
}
----
====

These are standards-based and let simple role-based constraints be applied but do not have the power Spring Security's native annotations.
To use the new expression-based syntax, you would use:

====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
open class MethodSecurityConfig {
	// ...
}
----
====

The equivalent Java code is:

====
.Java
[source,java,role="primary"]
----
public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
interface BankService {
    @PreAuthorize("isAnonymous()")
    fun readAccount(id: Long): Account

    @PreAuthorize("isAnonymous()")
    fun findAccounts(): Array<Account>

    @PreAuthorize("hasAuthority('ROLE_TELLER')")
    fun post(account: Account, amount: Double): Account
}
----
====

== GlobalMethodSecurityConfiguration

Sometimes, you may need to perform operations that are more complicated than are possible with the `@EnableGlobalMethodSecurity` annotation.
For these instances, you can extend the `GlobalMethodSecurityConfiguration`, ensuring that the `@EnableGlobalMethodSecurity` annotation is present on your subclass.
For example, if you wanted to provide a custom `MethodSecurityExpressionHandler`, you could use the following configuration:

====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler() {
		// ... create and return custom MethodSecurityExpressionHandler ...
		return expressionHandler;
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
open class MethodSecurityConfig : GlobalMethodSecurityConfiguration() {
    override fun createExpressionHandler(): MethodSecurityExpressionHandler {
        // ... create and return custom MethodSecurityExpressionHandler ...
        return expressionHandler
    }
}
----
====

For additional information about methods that can be overridden, see the Javadoc for the {security-api-url}org/springframework/security/config/annotation/method/configuration/GlobalMethodSecurityConfiguration.html[`GlobalMethodSecurityConfiguration`] class.

[[ns-global-method]]
== The <global-method-security> Element
This element is used to enable annotation-based security in your application (by setting the appropriate attributes on the element) and to group together security pointcut declarations that are applied across your entire application context.
You should only declare one `<global-method-security>` element.
The following declaration enables support for Spring Security's `@Secured`:

====
[source,xml]
----
<global-method-security secured-annotations="enabled" />
----
====

Adding an annotation to a method (on a class or interface) would then limit the access to that method accordingly.
Spring Security's native annotation support defines a set of attributes for the method.
These are passed to the `AccessDecisionManager` for it to make the actual decision.
The following example shows the `@Secured` annotation in a typical interface:

====
.Java
[source,java,role="primary"]
----
public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}
----


.Kotlin
[source,kotlin,role="secondary"]
----
interface BankService {
    @Secured("IS_AUTHENTICATED_ANONYMOUSLY")
    fun readAccount(id: Long): Account

    @Secured("IS_AUTHENTICATED_ANONYMOUSLY")
    fun findAccounts(): Array<Account>

    @Secured("ROLE_TELLER")
    fun post(account: Account, amount: Double): Account
}
----
====

Support for JSR-250 annotations can be enabled by using:

====
[source,xml]
----
<global-method-security jsr250-annotations="enabled" />
----
====

These are standards-based and allow simple role-based constraints to be applied, but they do not have the power Spring Security's native annotations.
To use the expression-based syntax, use:

====
[source,xml]
----
<global-method-security pre-post-annotations="enabled" />
----
====

The equivalent Java code is:

====
.Java
[source,java,role="primary"]
----
public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
interface BankService {
    @PreAuthorize("isAnonymous()")
    fun readAccount(id: Long): Account

    @PreAuthorize("isAnonymous()")
    fun findAccounts(): Array<Account>

    @PreAuthorize("hasAuthority('ROLE_TELLER')")
    fun post(account: Account, amount: Double): Account
}
----
====

Expression-based annotations are a good choice if you need to define simple rules that go beyond checking the role names against the user's list of authorities.

[NOTE]
====
The annotated methods will only be secured for instances which are defined as Spring beans (in the same application context in which method-security is enabled).
If you want to secure instances which are not created by Spring (using the `new` operator, for example) then you need to use AspectJ.
====

[NOTE]
====
You can enable more than one type of annotation in the same application, but only one type should be used for any interface or class as the behaviour will not be well-defined otherwise.
If two annotations are found which apply to a particular method, then only one of them will be applied.
====

[[ns-protect-pointcut]]
== Adding Security Pointcuts by using protect-pointcut

`protect-pointcut` is particularly powerful, as it lets you apply security to many beans with only a simple declaration.
Consider the following example:

====
[source,xml]
----
<global-method-security>
<protect-pointcut expression="execution(* com.mycompany.*Service.*(..))"
	access="ROLE_USER"/>
</global-method-security>
----
====

d.
This configuration protects all methods on beans declared in the application context whose classes are in the `com.mycompany` package and whose class names end in `Service`.
Only users with the `ROLE_USER` role can invoke these methods.
As with URL matching, the most specific matches must come first in the list of pointcuts, as the first matching expression is used.
Security annotations take precedence over pointcuts.
